<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LQQB&#39;s Blog (ง •̀_•́)ง</title>
  
  <subtitle>将一个大问题分解为若干小问题，然后一个一个解决</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qbqb.pro/"/>
  <updated>2018-09-03T09:44:37.941Z</updated>
  <id>http://qbqb.pro/</id>
  
  <author>
    <name>lqqb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringSecurity基本原理分析</title>
    <link href="http://qbqb.pro/2018/08/31/SpringSecurity%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://qbqb.pro/2018/08/31/SpringSecurity基本原理/</id>
    <published>2018-08-31T09:25:56.000Z</published>
    <updated>2018-09-03T09:44:37.941Z</updated>
    
    <content type="html"><![CDATA[<p><em>SpringSecurity</em> 是一个能够基于 <em>Spring</em> 的企业应用系统提供声明式的安全框架<a id="more"></a></p><h3 id="它能做什么"><a href="#它能做什么" class="headerlink" title="它能做什么"></a>它能做什么</h3><blockquote><p><strong>认证:</strong> 识别当前用户是谁<br><strong>授权:</strong> 判断当前用户是否有权限进行相关操作<br><strong>安全防护:</strong> 防止伪造身份</p></blockquote><p>如果要对 Web 资源进行保护，最好的方法莫过于 Filter, 要项对方法调用进行保护，最好的方法莫过于AOP, <code>(ﾉ ○ Д ○)ﾉ</code>。</p><h3 id="它是如何实现的"><a href="#它是如何实现的" class="headerlink" title="它是如何实现的"></a>它是如何实现的</h3><p>下面来简单的介绍一个 <strong>SpringSecurity 基本原理</strong> :<br>当一个请求要访问我们受 <strong>SpringSecurity</strong> 保护的 Web 资源的时候, 会先经过我们在 <em>Spring</em> 中设置的关于 <strong>SpringSecurity</strong> 的多层过滤器链,(如 <strong>UsernamePasswordAuthenticationFilter</strong>, <strong>BasicAuthenticationFilter</strong>),一个过滤器一个过滤器往下走,每通过一个过滤器的认证就会添加在请求中添加一个标记。如下图所示:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/31/SpringSecurity基本原理/filter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>然后勒，这些 Filter 怎么和我们的数据库联系在一起勒？</p><p>这些 <strong>Filter</strong> 并不直接处理用户的认证，也不直接处理用户的授权，而是把它们交给认证管理器 <strong>AuthenticationManager</strong> 和决策管理器 <strong>AccessDecisionManager</strong>。SpringSecurity 提供了多个Provider的实现类，拿 <strong>UsernamePasswordAuthenticationFilter</strong>举例，当我们调用这个 <strong>Filter</strong>，并通过<strong>AuthenticationManager</strong>调用到 <strong>DaoAuthenticationProvider</strong>, 这个 <strong>Provider</strong> 可以调用数据库来存储用户的认证数据。对于<strong>Voter</strong>，我们一般选择<strong>RoleVoter</strong>就够用了，它会根据我们配置中的设置来决定是否允许某一个用户访问制定的Web资源。认证跟授权的流程如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/31/SpringSecurity基本原理/认证和授权.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p> <strong>DaoAuthenticationProvider</strong>不直接操作数据库的，它把任务委托给了 <strong>UserDetailService</strong>，我们要做的就是现实 <strong>UserDetailService</strong>, 它既是连接我们数据库跟SpringSecurity的桥梁。UserDetailService 的要求也很简单，只需要返回一个 <strong>org.springframework.security.userdetails.User</strong> 对象的 <strong>loadUserByUsername(String userName)</strong> 方法<br>。因此，怎么设计数据库都可以，不管我们是用一个表还是两个表还是三个表，也不管我们是用户-授权，还是用户-角色-授权，还是用户-用户组-角色-授权，这些具体的东西 <strong>SpringSecurity</strong> 统统不关心，它只关心返回的那个User对象，至于怎么从数据库中读取数据，那就是我们自己的事了。</p><p><strong>UserDetailService</strong> 实现类部分代码,模拟从数据库中获取用户信息:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        User user = userRepository.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(username);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyUserPrincipal(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyUserPrincipal定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserPrincipal</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUserPrincipal</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SpringSecurity 不关心你用了几个表，它只关心UserDetails对象。而决定用户能否访问指定Web资源的，是RoleVoter类，无需任何修改它可以工作得很好，唯一的缺点是它只认ROLE_前缀。</p><h3 id="它的常用-Filter-总结"><a href="#它的常用-Filter-总结" class="headerlink" title="它的常用 Filter 总结"></a>它的常用 Filter 总结</h3><p>SpringSecurity 提供的Filter 不少，不过常用的只有这么几个，下面我们来总结一下：</p><blockquote><p><strong>ChannelProcessingFilter:</strong>  制定必须为https连接<br><strong>LogoutFilter:</strong>退出登录<br><strong>UsernamePasswordAuthenticationFilter:</strong> 账号密码登录<br><strong>RememberMeAuthenticationFilter:</strong> 记住用户<br><strong>FilterSecurityInterceptor:</strong> 这个过滤器是整个SpringSecurity过滤器链的最后一环</p></blockquote><p>接下来简短的来谈一谈，<strong>FilterSecurityInterceptor</strong> 这个过滤器的最后一环，也是最重要的一环。它的父类<strong>AbstractSecurityInterceptor</strong> 是一个实现了对受保护对象的访问进行拦截的抽象类,该抽象类包含了<strong>AccessDecisionManager(决策管理器)</strong>、<strong>AuthenticationManager(身份认证管理器)</strong>的setter， 可以通过<strong>Spring</strong> 自动注入，另外，资源角色授权器需要单独自定义注入。</p><p>其中有几个比较重要的方法,都会在<code>FilterSecurityInterceptor</code>中被调用:</p><blockquote><p><strong>beforeInvocation()方法:</strong> 实现了对访问受保护对象的权限校验，内部用到了<code>AccessDecisionManager</code>和<code>AuthenticationManager</code>;<br><strong>finallyInvocation()方法:</strong> 用于实现受保护对象请求完毕后的一些清理工作，主要是如果在<code>beforeInvocation()</code>中改变了<code>SecurityContext</code>，则在<code>finallyInvocation()</code>中需要将其恢复为原来的<code>SecurityContext</code>,该方法的调用应当包含在子类请求受保护资源时的finally语句块中;<br><strong>afterInvocation()方法:</strong> 实现了对返回结果的处理，在注入了AfterInvocationManager的情况下默认会调用其decide()方法。</p></blockquote><p>来看看 <code>FilterSecurityInterceptor</code> 的部分源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 。。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        FilterInvocation fi = <span class="keyword">new</span> FilterInvocation(request, response, chain);</span><br><span class="line">        <span class="keyword">this</span>.invoke(fi);    <span class="comment">//  invoke() 在Filter 的 doFilter（）中被调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FilterSecurityInterceptor 的核心代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span> &amp;&amp; fi.getRequest().getAttribute(<span class="string">"__spring_security_filterSecurityInterceptor_filterApplied"</span>) != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fi.getRequest().setAttribute(<span class="string">"__spring_security_filterSecurityInterceptor_filterApplied"</span>, Boolean.TRUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类的beforeInvocation方法，该方法实现了对访问受保护对象的权限校验，</span></span><br><span class="line">    <span class="comment">// 内部调用到了`AccessDecisionManager`和`AuthenticationManager`</span></span><br><span class="line">            InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 调用父类的finallyInvocation方法, 用于实现受保护对象请求完毕后的一些清理工作</span></span><br><span class="line">                <span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">// 用父类的afterInvocation方法,实现了对返回结果的处理，</span></span><br><span class="line">  <span class="comment">// 在注入了AfterInvocationManager的情况下默认会调用其decide()方法。</span></span><br><span class="line">            <span class="keyword">super</span>.afterInvocation(token, (Object)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 。。。。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最后说点什么"><a href="#最后说点什么" class="headerlink" title="最后说点什么"></a>最后说点什么</h3><p>感觉最后不说点什么，有点奇怪。。。<br>笔者目前也在学习的<strong>SpringSecurity</strong>， 目前是一个阶段性的总结，以后如果有更深的理解会继续更新。笔者并没有讲具体的实现细节，只是大概的过了一遍SpringSecurity的执行过程，有遗漏的错误的地方欢迎指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;SpringSecurity&lt;/em&gt; 是一个能够基于 &lt;em&gt;Spring&lt;/em&gt; 的企业应用系统提供声明式的安全框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://qbqb.pro/tags/Spring/"/>
    
      <category term="Java" scheme="http://qbqb.pro/tags/Java/"/>
    
      <category term="SpringSecurity" scheme="http://qbqb.pro/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>记一次git错误解决</title>
    <link href="http://qbqb.pro/2018/08/27/%E8%AE%B0%E4%B8%80%E6%AC%A1git%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%EF%BC%8C%E5%9B%9E%E9%A1%BEgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://qbqb.pro/2018/08/27/记一次git错误解决，回顾git常用命令/</id>
    <published>2018-08-27T02:23:06.000Z</published>
    <updated>2018-08-27T10:46:15.244Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次 git 错误，<strong> fatal: Path ‘XXX’ is in submodule ‘XXX’ </strong><br><a id="more"></a></p><p>将Hexo博客部署到 Github 跟 Codeing 的 Pages 之后，为了能方便的在其他电脑也能随时更新博客文章、Hexo 配置文件和主题配置文件，我们在 GitHub Pages 仓库上创建了一个名为 Hexo 的分支，用来存放 Hexo 博客的网站文件。具体的操作步骤参考<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener"><strong> 知乎上的一个高赞回复 </strong></a> 这里不详细展开 <strong> (ˉ▽ˉ；)… </strong> ）。创建分支 Hexo ,将网站文件提交到分支，在另外一台电脑 pull 下分支中网站文件，安装相关模块，一气呵成。。。</p><p>可是在<code>hexo server</code>本地运行的时候,无法运行? 检查了主题文件夹目录下 <code>themes/indigo</code> 既然是空的，远程仓库中的对应的文件夹图标往常不同，画风都变了 <code>(ﾉ ○ Д ○)ﾉ</code> ，还无法点击查看下级目录，与下图的图标类似：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/27/记一次git错误解决，回顾git常用命令/github显示.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一开始以为该文件目录,忘记推送至远程仓库，所以打算重新将该文件夹下的文件添加至暂存区，git add themes/indigo/* ,可是既然报错了, 错误信息 <code>** fatal: Path &#39;XXX&#39; is in submodule &#39;XXX&#39; **</code> ???</p><p>仔细对比了themes/indigo 下的文件，发现该文件既然有一个 .git 目录，推测是由于一个 git 项目下无法识别其他的 git 项目。</p><ul><li>把 <code>indigo</code> 主题文件复制一份删除 .git 文件</li><li><p>从当前的工作空间中和索引中删除主题文件 <code>indigo</code></p><blockquote><p> git rm -rf themes/indigo</p></blockquote></li><li><p>将 <code>indigo</code> 主题文件复制到原来的主题问题目录下，添加暂存区，提交版本库，推送分支<br>完成。<br>重新再另外一台电脑 拉取分支，可以正常运行~~~</p><!-- <img src="/github显示.png"> –&gt;</li></ul>--></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一次 git 错误，&lt;strong&gt; fatal: Path ‘XXX’ is in submodule ‘XXX’ &lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://qbqb.pro/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 使用小记</title>
    <link href="http://qbqb.pro/2018/08/20/Hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
    <id>http://qbqb.pro/2018/08/20/Hexo使用小记/</id>
    <published>2018-08-20T06:06:12.000Z</published>
    <updated>2018-08-27T09:04:25.561Z</updated>
    
    <content type="html"><![CDATA[<p>hexo 是一个快速、简洁且高效的博客框架<a id="more"></a>，本网站由Hexo 搭建而成，使用了的主题是有着Design风格的Hexo主题 indigo。下面我们简单的总结一下搭建过程。</p><blockquote><p>参考 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a><br>参考 <a href="https://youngwilliamz.github.io/2018-07-10-Hexo-Markdown/" target="_blank" rel="noopener">Hexo 使用MD编辑技巧 </a><br>参考 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">Material Design风格的Hexo主题</a><br>参考 <a href="https://www.jianshu.com/p/86557c34b671" target="_blank" rel="noopener">Hexo Seo优化</a></p></blockquote><h3 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h3><p>安装前,请检查电脑中是否安装下列应用程序</p><blockquote><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener"><code>Node.js</code></a><br><a href="https://git-scm.com/" target="_blank" rel="noopener"><code>Git</code></a></p></blockquote><p>没有的话，请先安装吧,建议最新版本，可以避免部分安装上的错误。如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><blockquote><p><code>npm install -g hexo-cli</code></p></blockquote><h3 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h3><blockquote><p>hexo init [folder]         <code># 新建网站，folder为文件夹名</code><br>hexo clean                <code># 清除缓存文件</code><br>hexo g -d                     <code># 生成静态文件，并自动部署网站</code><br>hexo new “postname”         <code># 新建一篇文章</code><br>hexo server                 <code># 启动服务器</code></p></blockquote><h3 id="Hexo-目录结构"><a href="#Hexo-目录结构" class="headerlink" title="Hexo 目录结构"></a>Hexo 目录结构</h3><p> 使用新建网站命令创建Hexo的目录结构</p><blockquote><p>hexo init <code>folder</code><br>cd <code>folder</code><br>npm install</p></blockquote><p>整个过程只需要两三分钟左右的时间 emmmm…. , 文件的目录结构如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/20/Hexo使用小记/目录结构图.png" alt="目录结构图" title="">                </div>                <div class="image-caption">目录结构图</div>            </figure><br><strong> 下面是比较常用到的几个文件 </strong></p><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的配置信息，可以在此配置大部分的参数,在新建Hexo 目录的根路径上</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="Hexo-主题安装"><a href="#Hexo-主题安装" class="headerlink" title="Hexo 主题安装"></a>Hexo 主题安装</h3><p>安装该主题需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令</p><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:yscoder/hexo-theme-indigo.git themes/indigo</p></blockquote><p>并编辑站点配置文件，<strong> _config.yml </strong> 启用主题 <strong> theme: indigo </strong>,详细配置信息可查看<a href="https://github.com/yscoder/hexo-theme-indigo/wiki" target="_blank" rel="noopener">文档</a>,根据具体自己的需求进行配置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/20/Hexo使用小记/主题效果.png" alt="主题效果" title="">                </div>                <div class="image-caption">主题效果</div>            </figure><hr><p>后续补充<br><!-- <img src="/主题效果.png" width="300" height="400"> –&gt;</p>--></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo 是一个快速、简洁且高效的博客框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://qbqb.pro/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客，该写点什么~</title>
    <link href="http://qbqb.pro/2018/08/16/first/"/>
    <id>http://qbqb.pro/2018/08/16/first/</id>
    <published>2018-08-16T12:00:28.000Z</published>
    <updated>2018-08-16T13:34:44.066Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>这是我在这个网站写的<strong>第一篇博客</strong>，不知到写点什么好， emmmmm~  一个人如果做的东西没有特点就很难得到别人的喜欢，我是一个比较愚钝的人，踩过很多坑，努力填了很多坑，同时也认识到了自己的不足，这是一个用来记录我学习踩坑的地方。</p><h4 id="在这里送上我最喜欢的两句话"><a href="#在这里送上我最喜欢的两句话" class="headerlink" title="在这里送上我最喜欢的两句话"></a>在这里送上我最喜欢的两句话</h4><blockquote><p>我们使用时间的方式就是我们塑造自己的方式。</p></blockquote><blockquote><p>我们的人生是因为有爱，才突显了光；是因为有消逝，所以存在才会有意义。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
      <category term="记录" scheme="http://qbqb.pro/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法测试</title>
    <link href="http://qbqb.pro/2018/08/14/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://qbqb.pro/2018/08/14/我的世界/</id>
    <published>2018-08-14T02:21:10.000Z</published>
    <updated>2018-08-15T05:45:30.332Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言,它用简洁的语法代替排版,使我们专心于码字<br><a id="more"></a></p><h3 id="markdown语法”-”表示三级标题，二级标题，一级标题向上类推"><a href="#markdown语法”-”表示三级标题，二级标题，一级标题向上类推" class="headerlink" title="markdown语法”###”表示三级标题，二级标题，一级标题向上类推"></a>markdown语法”###”表示三级标题，二级标题，一级标题向上类推</h3><ul><li>无序列表用”*”表示</li><li>攻击防护( 防止伪造身份 )</li></ul><h3 id="普通的代码块-用-codeblock-与-endcodeblock-标记"><a href="#普通的代码块-用-codeblock-与-endcodeblock-标记" class="headerlink" title="普通的代码块 用 codeblock 与 endcodeblock 标记"></a>普通的代码块 用 codeblock 与 endcodeblock 标记</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相对路径引用的标签插件"><a href="#相对路径引用的标签插件" class="headerlink" title="相对路径引用的标签插件"></a>相对路径引用的标签插件</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/我的世界/test1.jpg" alt="测试图片" title="">                </div>                <div class="image-caption">测试图片</div>            </figure><img src="/2018/08/14/我的世界/test2.png" width="100" height="100">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown 是一种轻量级标记语言,它用简洁的语法代替排版,使我们专心于码字&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://qbqb.pro/tags/Hexo/"/>
    
      <category term="markdown" scheme="http://qbqb.pro/tags/markdown/"/>
    
  </entry>
  
</feed>
