<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LQQB&#39;s Blog (ง •̀_•́)ง</title>
  
  <subtitle>将一个大问题分解为若干小问题，然后一个一个解决</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qbqb.pro/"/>
  <updated>2018-09-29T09:40:00.734Z</updated>
  <id>http://qbqb.pro/</id>
  
  <author>
    <name>lqqb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java集合——List类集合</title>
    <link href="http://qbqb.pro/2018/09/26/Java%E9%9B%86%E5%90%88%E2%80%94%E2%80%94List%E7%B1%BB%E9%9B%86%E5%90%88/"/>
    <id>http://qbqb.pro/2018/09/26/Java集合——List类集合/</id>
    <published>2018-09-26T01:34:19.000Z</published>
    <updated>2018-09-29T09:40:00.734Z</updated>
    
    <content type="html"><![CDATA[<p>上一章节我们总结了Java集合框架的整体结构，现在就来看看集合的第一大体系 List。<a id="more"></a>接下来还是要从 List 的层次结构开始入手，来理解Java的集合框架中的 List 结构。</p><h3 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/26/Java集合——List类集合/集合框架List.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从上图中可以看出 List 是有序的 Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，这类似于 Java 的数组。</p><p>List 在Collection 基础上新增的方法包括:</p><ul><li><code>get(int)</code> - 返回指定index位置上的对象</li><li><code>add(E)/add(int, E)</code> - 在List末尾/指定index位置上插入一个对象</li><li><code>set(int, E)</code> - 替换置于List指定index位置上的对象</li><li><code>indexOf(Object)</code> - 返回指定对象在List中的index位置</li><li><code>subList(int,int)</code> - 返回指定起始index到终止index的子List对象</li></ul><h3 id="List接口的常用实现类："><a href="#List接口的常用实现类：" class="headerlink" title="List接口的常用实现类："></a>List接口的常用实现类：</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>底层由数组的操作实现的List</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p><strong>ArrayList &lt; E &gt;</strong> 提供了3种构造方式，默认的构造函数会初始化一个空的数组，在之后添加元素的过程中会对数组进行扩容，扩容操作在一定程度上会影响数组的性能。如果能提前预估最终的数组使用空间大小，可以通过 <code>ArrayList(int initialCapacity)</code> 这种构造方式来初始化数组大小，这样会减少扩容造成的性能损失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个初始容量为10的空列表。</span></span><br><span class="line"><span class="comment">// static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定元素的列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;[type]&#125; Collection&lt;? extends E&gt; c [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">elementData = c.toArray();</span><br><span class="line"><span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">    elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 替换为空数组</span></span><br><span class="line"><span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常用的操作"><a href="#常用的操作" class="headerlink" title="常用的操作"></a>常用的操作</h5><hr><h6 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h6><p>值得一提的是当数据需要<code>扩容</code>时，执行到最后阶段就会调用到 <code>Arrays.copyOf()</code> 方法，这是创建一个新的数组并将数据拷贝到新数组中，且把引用赋值给elementData。在这里就可以看出在<code>扩容</code>的情况下，对性能上存在一定的损耗，时间复杂度也也会从O(1)提升到O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 检查数组容量操作</span></span><br><span class="line">ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">elementData[size++] = e;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;[type]&#125; Object[] elementData   [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;[type]&#125; int      minCapacity   [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;[type]&#125;          [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当容量不够时，调用grow(int minCapacity) 方法进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;[type]&#125; int minCapacity   [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;[type]&#125;     [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止内存溢出，</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量以确保它至少能容纳，最小容量参数指定的元素数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;[type]&#125; int minCapacity   [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;[type]&#125;     [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 每次扩容在原容量的基础上增加一半，新的容量为原容量的1.5倍。</span></span><br><span class="line">    <span class="comment">// 这里使用 &gt;&gt; 1,进行除以2操作</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 扩容成功移动数据</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h6><p><strong>删除指定位置的元素</strong>: 首先需检查index的合法性，获取指定位置上的旧元素，计算需要移动的长度，如果需要移动的，则调用<code>System.arraycopy()</code>方法，通过拷贝的方式将index位置上的元素往前移。将数组最后一位设置成null，方便GC工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index的合法性</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取指定位置上的旧元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">    <span class="comment">// 将数组最后一位设置成null，方便GC工作</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= size)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除指定元素</strong>: 这里删除的是数组中第一个找到的元素。<code>fastRemove()</code>方法移除。从 <code>ArrayList &lt; E &gt;</code>的删除方法可以看得出，当旧元素删除时，需要将删除元素后的元素往前移，这同样是一个消耗性能的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有的删除方法，不进行边界检查，没有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;[type]&#125; int index         [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;[type]&#125;     [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h6><p>获取元素的操作相对简单，首先同样需要检查index的合法性，然后直接取数组中 index 位置元素返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList 是有序并且可以元素重复的集合，底层是基于双向链表的。</p><h5 id="双向链表结构"><a href="#双向链表结构" class="headerlink" title="双向链表结构"></a>双向链表结构</h5><p>那首先就先来看看LinkedList的链表的数据结构是什么样的吧.</p><ol><li><code>first</code> 和 <code>last</code> 均是 <code>Node</code> 类的实例。 <code>first</code> 指向头结点，<code>last</code> 指向的尾节点。</li><li><code>Node</code> 为节点对象。<code>Node</code> 是 <code>LInkedList</code> 的内部类，定义了存储的数据元素，前一个节点和后一个节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//链表的第一个元素</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的最后一个元素</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的内部类表示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//当前元素</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">//下一个元素</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">//上一个元素</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在空间的最大化利用上链表比数组更加合理。这并不代表链表使用的空间小，相反，链表每个节点因为要存储下一个节点引用（双向链表会存储上下两个节点的引用），在相同元素空间使用上会比数组大的多。</p><h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><p><strong>LinkedList</strong> 提供了两个构造方法：<code>LinkedList()</code> 和 <code>LinkedList(Collection&lt;? extends E&gt; c)</code></p><p><code>LinkedList()</code> 仅仅构造一个空的列表，size = 0,first 和 last 都为 null, 没有任何元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造方法，生成一个空的链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 入参的元素 生成一个LinkedList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line"><span class="comment">// 将指定集合中的所有元素插入到此中</span></span><br><span class="line">addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常用的操作-1"><a href="#常用的操作-1" class="headerlink" title="常用的操作"></a>常用的操作</h5><hr><h6 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h6><p><strong>LinkedList &lt; E &gt;</strong> 在添加元素时由于链表的特性，不需要考虑扩容的问题，但LinkedList<e>每次都需要new一个Node来存储元素。</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表的最后添加元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;[type]&#125; E e [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">linkLast(e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line"><span class="comment">// 创建一个新的节点元素，并放在最后</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">last = newNode;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">first = newNode;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l.next = newNode;</span><br><span class="line">size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定索引位置插入元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;[type]&#125; int index   [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;[type]&#125; E   element [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">//直接添加元素到末尾</span></span><br><span class="line">        linkLast(element);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="comment">//添加到指定位置前先查找当前位置已经存在的元素</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line"><span class="comment">// pred指向succ的前向结点</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line"><span class="comment">// 生成一个新结点，结点的值为e，其前向指针指向pred,后向指针指向succ</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line"><span class="comment">// succ的前向指针指向newNode</span></span><br><span class="line">succ.prev = newNode;</span><br><span class="line"><span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">// 如果pred为null,则表示succ为头结点，此时头结点指向最新生成的结点newNode</span></span><br><span class="line">first = newNode;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// pred的后向指针指向新生成的结点，此时已经完成了结点的插入操作</span></span><br><span class="line">pred.next = newNode;</span><br><span class="line">size++;</span><br><span class="line">modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h6><p><strong>LinkedList &lt; E &gt;</strong> 通过向后遍历链表的方式查找到对应的元素直接删除即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索并删除此列表的头部(第一个元素)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;[type]&#125; [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeFirst();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此列表中删除并返回第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;[type]&#125; [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 对索引位置进行校验</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解除节点的链接关系</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert x != null;</span></span><br><span class="line">       <span class="keyword">final</span> E element = x.item;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果prev为空，则x结点为first结点，此时first结点指向next结点（x的后向结点）</span></span><br><span class="line">           first = next;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           prev.next = next; <span class="comment">// x的前向结点的后向指针指向x的后向结点</span></span><br><span class="line">           x.prev = <span class="keyword">null</span>;<span class="comment">// 释放x的前向指针</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果next结点为空，则x结点为尾部结点，此时last结点指向prev结点（x的前向结点）</span></span><br><span class="line">           last = prev;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           next.prev = prev; <span class="comment">// x的后向结点的前向指针指向x的前向结点</span></span><br><span class="line">           x.next = <span class="keyword">null</span>; <span class="comment">// 释放x的后向指针</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放x的值节点，这样该节点就可以被GC回收</span></span><br><span class="line">       x.item = <span class="keyword">null</span>;</span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h6 id="获取元素-1"><a href="#获取元素-1" class="headerlink" title="获取元素"></a>获取元素</h6><p><strong>LinkedList &lt; E &gt;</strong> 根据 索引获取元素，其实也没有什么好说的，根据指定索引小于LinkedList长度一半，则从首结点开始遍历;若不是从尾结点开始遍历。从时间复制度上来看是 O(n) 级别。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="keyword">return</span> node(index).item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素索引处的（非null）节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;[type]&#125; int index         [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;[type]&#125;     [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 若指定索引小于LinkedList长度一半，则从首结点开始遍历;若不是从尾结点开始遍历</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="List集合实用操作"><a href="#List集合实用操作" class="headerlink" title="List集合实用操作"></a>List集合实用操作</h3><p>接下来就来讲讲 <code>Java8</code> 新增的特性流式数据处理，它使得我们对集合操作更加的简洁，通常我们需要多行代码才能完成的操作，借助于流式处理可以在一行中实现。</p><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    students = <span class="keyword">new</span> ArrayList&lt;Student&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="keyword">new</span> Student( <span class="string">"孔明"</span>, <span class="number">20</span>, <span class="string">"武汉大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student(<span class="string">"伯约"</span>, <span class="number">21</span>,  <span class="string">"武汉大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student( <span class="string">"玄德"</span>, <span class="number">22</span>, <span class="string">"武汉大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student(<span class="string">"云长"</span>, <span class="number">21</span>, <span class="string">"武汉大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student(<span class="string">"翼德"</span>, <span class="number">21</span>,  <span class="string">"华中科技大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student(<span class="string">"元直"</span>, <span class="number">23</span>,  <span class="string">"华中科技大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student( <span class="string">"奉孝"</span>, <span class="number">23</span>,<span class="string">"华中科技大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student( <span class="string">"仲谋"</span>, <span class="number">22</span>, <span class="string">"浙江大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student( <span class="string">"鲁肃"</span>, <span class="number">23</span>,<span class="string">"浙江大学"</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Student(<span class="string">"丁奉"</span>, <span class="number">24</span>,  <span class="string">"南京大学"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ins = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="number">2</span>); add(<span class="number">2</span>);add(<span class="number">2</span>);</span><br><span class="line">            add(<span class="number">4</span>);add(<span class="number">4</span>);add(<span class="number">4</span>);add(<span class="number">4</span>);</span><br><span class="line">            add(<span class="number">6</span>);add(<span class="number">6</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="流式数据处理"><a href="#流式数据处理" class="headerlink" title="流式数据处理"></a>流式数据处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// filter 筛选</span></span><br><span class="line">       <span class="comment">// [Student&#123;name='孔明', age=20, school='武汉大学'&#125;, Student&#123;name='伯约', age=21, school='武汉大学'&#125;,</span></span><br><span class="line">       <span class="comment">// Student&#123;name='玄德', age=22, school='武汉大学'&#125;, Student&#123;name='云长', age=21, school='武汉大学'&#125;]</span></span><br><span class="line">       List&lt;Student&gt; filter_list = students.stream().filter( student -&gt; <span class="string">"武汉大学"</span>.equals(student.getSchool()) )</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       System.out.println(filter_list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// distinct 去重</span></span><br><span class="line">       <span class="comment">// [2, 4, 6]</span></span><br><span class="line">       List&lt;Integer&gt; distinct_list = ins.stream()</span><br><span class="line">               .filter( in -&gt; in%<span class="number">2</span> == <span class="number">0</span> ).distinct()</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// limit 分页</span></span><br><span class="line">       <span class="comment">// [Student&#123;name='孔明', age=20, school='武汉大学'&#125;, Student&#123;name='伯约', age=21, school='武汉大学'&#125;]</span></span><br><span class="line">       List&lt;Student&gt; limit_list = students.stream()</span><br><span class="line">               .filter( student -&gt; <span class="string">"武汉大学"</span>.equals(student.getSchool()) ).limit(<span class="number">2</span>)</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// skit 与limit相反，跳过前n个元素</span></span><br><span class="line">       <span class="comment">// [Student&#123;name='云长', age=21, school='武汉大学'&#125;]</span></span><br><span class="line">       List&lt;Student&gt; skit_list = students.stream()</span><br><span class="line">               .filter(student -&gt; <span class="string">"武汉大学"</span>.equals(student.getSchool()))</span><br><span class="line">               .skip(<span class="number">3</span>)</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// map 映射</span></span><br><span class="line">       <span class="comment">// [翼德, 元直, 奉孝]</span></span><br><span class="line">       List&lt;String&gt; map_list = students.stream()</span><br><span class="line">               .filter(student -&gt; <span class="string">"华中科技大学"</span>.equals(student.getSchool()))</span><br><span class="line">               .map(Student::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章节我们总结了Java集合框架的整体结构，现在就来看看集合的第一大体系 List。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://qbqb.pro/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合——集合框架汇总</title>
    <link href="http://qbqb.pro/2018/09/18/Java%E9%9B%86%E5%90%88%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB/"/>
    <id>http://qbqb.pro/2018/09/18/Java集合——集合框架汇总/</id>
    <published>2018-09-18T03:18:59.000Z</published>
    <updated>2018-09-26T01:09:33.913Z</updated>
    
    <content type="html"><![CDATA[<p>集合是在任何语言中都是重要的基础知识，不同的集合在实现上采用了各种不同的数据结构。<a id="more"></a>接下来就从Java集合框架的层次关系开始入手，来理解Java的集合框架。</p><h3 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h3><p>一个好的框架会在设计上考虑将接口与实现分离，而 Java集合框架从接口的整体设计就可以快速明确这个框架的作用和功能。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/18/Java集合——集合框架汇总/Java集合框架结构.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过上面的接口框架图可以看出: Collection<e> 和 Map&lt;K,V&gt; 是java.util 框架中的两个根接口，代表了两种不同的数据结构:集合和映射。</e></p><p>下面我们来分别来说下这些核心接口的基本功能:</p><h4 id="Collection-lt-E-gt"><a href="#Collection-lt-E-gt" class="headerlink" title="Collection&lt; E &gt;"></a>Collection&lt; E &gt;</h4><p>Collection&lt; E &gt;接口是集合的根接口，他代表了一组元素。但是Collection<e>并不关心这组元素是否重复，是否有序。他只提供操作对这组元素的基本操作方法，怎么添加，怎么删除，怎么循环。所有的实现类都必须提供这些方法。</e></p><h4 id="Iterable-lt-T-gt"><a href="#Iterable-lt-T-gt" class="headerlink" title="Iterable &lt; T &gt;"></a>Iterable &lt; T &gt;</h4><p>所有的集合类，都实现了Iterator方法<code>Iterator&lt;E&gt; iterator()</code> ，Iterator&lt; E &gt; 这是一个用于遍历集合中元素的接口，主要包含以下三种方法：</p><ol><li>hasNext() 是否还有下一个元素。</li><li>next() 返回下一个元素。</li><li>remove() 删除当前元素。</li></ol><h4 id="Map-lt-K-V-gt"><a href="#Map-lt-K-V-gt" class="headerlink" title="Map&lt;K,V&gt;"></a>Map&lt;K,V&gt;</h4><p>API说明上关于Map&lt;K,V&gt;的说明非常精炼：从键映射到值的一个对象，键不能重复，每个键至多映射到一个值。 从键不能重复这个特点很容易想到通过Set<e>来实现键，他的接口方法Set<k> keySet()也证明了这点</k></e></p><h4 id="List-lt-E-gt-（有序、可重复）"><a href="#List-lt-E-gt-（有序、可重复）" class="headerlink" title="List&lt; E &gt;（有序、可重复）"></a>List&lt; E &gt;（有序、可重复）</h4><p>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</p><h4 id="Set-lt-E-gt-（无序、不能重复）"><a href="#Set-lt-E-gt-（无序、不能重复）" class="headerlink" title="Set&lt; E &gt;（无序、不能重复）"></a>Set&lt; E &gt;（无序、不能重复）</h4><p>Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。</p><blockquote><p>除了上述的接口以及抽象类以外，java.util框架还提供了一些其他结构，在使用频率上不是太高，比如Queue&lt; E &gt; ，Deque&lt; E &gt; 等。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合是在任何语言中都是重要的基础知识，不同的集合在实现上采用了各种不同的数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://qbqb.pro/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浏览器身份标识User-Agent的故事</title>
    <link href="http://qbqb.pro/2018/09/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BA%AB%E4%BB%BD%E6%A0%87%E8%AF%86User-Agent%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://qbqb.pro/2018/09/10/浏览器身份标识User-Agent的故事/</id>
    <published>2018-09-10T03:38:15.000Z</published>
    <updated>2018-09-10T06:42:36.360Z</updated>
    
    <content type="html"><![CDATA[<p>你是否好奇标识浏览器身份的User-Agent，为什么每个浏览器都有Mozilla字样？<a id="more"></a></p><blockquote><p>原文：<a href="http://webaim.org/blog/user-agent-string-history/" target="_blank" rel="noopener">http://webaim.org/blog/user-agent-string-history/</a><br>译文：<a href="http://www.cnblogs.com/ifantastic/p/3481231.html" target="_blank" rel="noopener">http://www.cnblogs.com/ifantastic/p/3481231.html</a><br>译者：iFantasticMe</p></blockquote><h5 id="举例"><a href="#举例" class="headerlink" title="举例:"></a>举例:</h5><blockquote><p><strong>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36</strong><br><strong>Mozilla/5.0 (Linux; U; Android 4.1.2; zh-tw; GT-I9300 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</strong><br><strong>Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) Gecko/20100101 Firefox/20.0</strong><br><strong>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0)</strong></p></blockquote><p>故事还得从头说起，最初的主角叫NCSA Mosaic，简称Mosaic（马赛克），是1992年末位于伊利诺伊大学厄巴纳-香槟分校的国家超级计算机应用中心（National Center for Supercomputing Applications，简称NCSA）开发，并于1993年发布的一款浏览器。它自称“NCSA_Mosaic/2.0（Windows 3.1）”，Mosaic可以同时展示文字和图片，从此浏览器变得有趣多了。</p><p>然而很快就出现了另一个浏览器，这就是著名的Mozilla，中文名称摩斯拉。一说 Mozilla = Mosaic + Killer，意为Mosaic杀手，也有说法是 Mozilla = Mosaic &amp; Godzilla，意为马赛克和哥斯拉，而Mozilla最初的吉祥物是只绿色大蜥蜴，后来更改为红色暴龙，跟哥斯拉长得一样。但Mosaic对此非常不高兴，于是后来Mozilla更名为Netscape，也就是网景。Netscape自称“Mozilla/1.0(Win3.1)”，事情开始变得更加有趣。网景支持框架（frame），由于大家的喜欢框架变得流行起来，但是Mosaic不支持框架，于是网站管理员探测user agent，对Mozilla浏览器发送含有框架的页面，对非Mozilla浏览器发送没有框架的页面。</p><p>后来网景拿微软寻开心，称微软的Windows是“没有调试过的硬件驱动程序”。微软很生气，后果很严重。此后微软开发了自己的浏览器，这就是Internet Explorer，并希望它可以成为Netscape Killer。IE同样支持框架，但它不是Mozilla，所以它总是收不到含有框架的页面。微软很郁闷很快就沉不住气了，它不想等到所有的网站管理员都了解IE并且给IE发送含有框架的页面，它选择宣布IE是兼容Mozilla，并且模仿Netscape称IE为“Mozilla/1.22(compatible; MSIE 2.0; Windows 95)”，于是IE可以收到含有框架的页面了，所有微软的人都嗨皮了，但是网站管理员开始晕了。</p><p>因为微软将IE和Windows捆绑销售，并且把IE做得比Netscape更好，于是第一次浏览器血腥大战爆发了，结果是Netscape以失败退出历史舞台，微软更加嗨皮。但没想到Netscape居然以Mozilla的名义重生了，并且开发了Gecko，这次它自称为“Mozilla/5.0(Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826”。Gecko是一款渲染引擎并且很出色。Mozilla后来变成了Firefox，并自称“Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108、Firefox/1.0”。Firefox性能很出色，Gecko也开始攻城略地，其他新的浏览器使用了它的代码，并且将它们自己称为“Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.2) Gecko/20040825 Camino/0.8.1”，以及“Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.8) Gecko/20071008 SeaMonkey/1.0”，每一个都将自己装作Mozilla，而它们全都使用Gecko。</p><p>Gecko很出色，而IE完全跟不上它，因此user agent探测规则变了，使用Gecko的浏览器被发送了更好的代码，而其他浏览器则没有这种待遇。Linux的追随者对此很难过，因为他们编写了Konqueror，它的引擎是KHTML，他们认为KHTML和Gecko一样出色，但却因为不是Gecko而得不到好的页面，于是Konqueror为得到更好的页面开始将自己伪装成“like Gecko”，并自称为“Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)”。自此user agent变得更加混乱。</p><p>这时更有Opera跳出来说“毫无疑问，我们应该让用户来决定他们想让我们伪装成哪个浏览器。”于是Opera干脆创建了菜单项让用户自主选择让Opera浏览器变成“Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51”，或者“Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51”， 或者“Opera/9.51 (Windows NT 5.1; U; en)”。</p><p>后来苹果开发了Safari浏览器，并使用KHTML作为渲染引擎，但苹果加入了许多新的特性，于是苹果从KHTML另辟分支称之为WebKit，但它又不想抛弃那些为KHTML编写的页面，于是Safari自称为“Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5”，这进一步加剧了user agent的混乱局面。</p><p>因为微软十分忌惮Firefox，于是IE重装上阵，这次它自称为“Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) ”，并且渲染效果同样出色，但是需要网站管理员的指令它这么做才行。</p><p>再后来，谷歌开发了Chrome浏览器，Chrome使用Webkit作为渲染引擎，和Safari之前一样，它想要那些为Safari编写的页面，于是它伪装成了Safari。于是Chrome使用WebKit，并将自己伪装成Safari，WebKit伪装成KHTML，KHTML伪装成Gecko，最后所有的浏览器都伪装成了Mozilla，这就是为什么所有的浏览器User-Agent里都有Mozilla。Chrome自称为“Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13”。</p><p>因为以上这段历史，现在的User-Agent字符串变得一团糟，几乎根本无法彰显它最初的意义。追根溯源，微软可以说是这一切的始作俑者，但后来每一个人都在试图假扮别人，最终把User-Agent搞得混乱不堪。</p><p>一句话结论：因为网站开发者可能会因为你是某浏览器（这里是 Mozilla），所以输出一些特殊功能的程序代码（这里指好的特殊功能），所以当其它浏览器也支持这种好功能时，就试图去模仿 Mozilla 浏览器让网站输出跟 Mozilla 一样的内容，而不是输出被阉割功能的程序代码。<code>大家都为了让网站输出最好的内容，都试图假装自己是 Mozilla ,一个已经不存在的浏览器……</code></p><h4 id="附各大浏览器诞生年表："><a href="#附各大浏览器诞生年表：" class="headerlink" title="附各大浏览器诞生年表："></a>附各大浏览器诞生年表：</h4><blockquote><p><strong>1993年1月23日：Mosaic</strong><br><strong>1994年12月：Netscape</strong><br><strong>1994年：Opera</strong><br><strong>1995年8月16日：Internet Explorer</strong><br><strong>1996年10月14日：Kongqueror</strong><br><strong>2003年1月7日：Safari</strong><br><strong>2008年9月2日：Chrome</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否好奇标识浏览器身份的User-Agent，为什么每个浏览器都有Mozilla字样？&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="http://qbqb.pro/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="浏览器" scheme="http://qbqb.pro/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://qbqb.pro/2018/09/04/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://qbqb.pro/2018/09/04/git常用命令/</id>
    <published>2018-09-04T07:11:03.000Z</published>
    <updated>2018-09-04T10:03:51.193Z</updated>
    
    <content type="html"><![CDATA[<p>Git做为一个开源的分布式版本控制系统,程序员的必备技能之一,今天就来总结一下关于Git的常用命令。<a id="more"></a><br>Git 相比于其他的版本控制系统来说，唯一的缺点可能就是学习周期相对较长，且不符合常规思维。不过当你习惯了这种管理方式，就能看到 Git 的优点了。下面这张图就可以描述出 Git 的工作过程，以及我们开发日常中经常用到的 Git 命令。当然日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/04/git常用命令/git构造空间.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><blockquote><p>参考自 <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">阮一峰的网络日志 》常用 Git 命令清单</a></p></blockquote><h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h3><blockquote><p>#在当前目录新建一个Git代码库<br><strong>git init</strong></p><p>#新建一个目录，将其初始化为Git代码库<br><strong>git init [project-name]</strong></p><p>#下载一个项目和它的整个代码历史</p><font color="Red">git clone [url]</font></blockquote><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)。</p><blockquote><p>#显示当前的Git配置<br><strong>git config –list</strong></p><p>#编辑Git配置文件<br><strong>git config -e [–global]</strong></p><p>#设置提交代码时的用户信息<br><strong>git config [–global] user.name “[name]”</strong><br><strong>git config [–global] user.email “[email address]”</strong></p></blockquote><h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><blockquote><p>#添加指定文件到暂存区</p><font color="Red">git  add [file1] [file2] …</font><p>#添加指定目录到暂存区，包括子目录<br><strong>git add [dir]</strong></p><p>#添加当前目录的所有文件到暂存区</p><font color="Red">git add .</font><p>#添加每个变化前，都会要求确认</p><p>#对于同一个文件的多处变化，可以实现分次提交<br><strong>git add -p</strong></p><p>#删除工作区文件，并且将这次删除放入暂存区<br><strong>git rm [file1] [file2] …</strong></p><p>#停止追踪指定文件，但该文件会保留在工作区<br><strong>git rm –cached [file]</strong></p><p>#改名文件，并且将这个改名放入暂存区<br><strong>git mv [file-original] [file-renamed]</strong></p></blockquote><h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h3><blockquote><p>#提交暂存区到仓库区</p><font color="Red">git commit -m [message]</font><p>#提交暂存区的指定文件到仓库区</p><font color="Red">git commit [file1] [file2] … -m [message]</font><p>#提交工作区自上次commit之后的变化，直接到仓库区<br><strong>git commit -a</strong></p><p>#提交时显示所有diff信息<br><strong>git commit -v</strong></p><p>#使用一次新的commit，替代上一次提交</p><p>#如果代码没有任何新变化，则用来改写上一次commit的提交信息<br><strong>git commit –amend -m [message]</strong></p><p>#重做上一次commit，并包括指定文件的新变化<br><strong>git commit –amend [file1] [file2] …</strong></p></blockquote><h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h3><blockquote><p>#列出所有本地分支</p><font color="Red">git branch</font><p>#列出所有远程分支<br><strong>git branch -r</strong></p><p>#列出所有本地分支和远程分支</p><font color="Red">git branch -a</font><p>#新建一个分支，但依然停留在当前分支</p><font color="Red">git branch [branch-name]</font><p>#新建一个分支，并切换到该分支</p><font color="Red">git checkout -b [branch]</font><p>#新建一个分支，指向指定commit<br><strong>git branch [branch] [commit]</strong></p><p>#新建一个分支，与指定的远程分支建立追踪关系<br><strong>git branch –track [branch] [remote-branch]</strong></p><p>#切换到指定分支，并更新工作区<br><strong>git checkout [branch-name]</strong></p><p>#切换到上一个分支</p><font color="Red">git checkout -</font><p>#建立追踪关系，在现有分支与指定的远程分支之间<br><strong>git branch –set-upstream [branch] [remote-branch]</strong></p><p>#合并指定分支到当前分支<br><strong>git merge [branch]</strong></p><p>#选择一个commit，合并进当前分支<br><strong>git cherry-pick [commit]</strong></p><p>#删除分支<br><strong>git branch -d [branch-name]</strong></p><p>#删除远程分支<br><strong>git push origin –delete [branch-name]</strong><br><strong>git branch -dr [remote/branch]</strong></p></blockquote><h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><blockquote><p>#列出所有tag&gt; <strong>git tag</strong></p><p>#新建一个tag在当前commit&gt; <strong>git tag [tag]</strong></p><p>#新建一个tag在指定commit&gt; <strong>git tag [tag] [commit]</strong></p><p>#删除本地tag&gt; <strong>git tag -d [tag]</strong></p><p>#删除远程tag&gt; <strong>git push origin :refs/tags/[tagName]</strong></p><p>#查看tag信息&gt; <strong>git show [tag]</strong></p><p>#提交指定tag<br><strong>git push [remote] [tag]</strong></p><p>#提交所有tag<br><strong>git push [remote] –tags</strong></p><p>#新建一个分支，指向某个tag<br><strong>git checkout -b [branch] [tag]</strong></p></blockquote><h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><blockquote><p>#显示 有变更的文件&gt; <font color="Red">git status</font></p><p>#显示 当前分支的版本历史&gt; <font color="Red">git log</font></p><p>#commit历史，以及每次commi&gt;发生变更的文件&gt; <strong>git log –stat</strong></p><p>#搜索提交历史，根据关键词&gt; <strong>git log -S [keyword]</strong></p><p>#显示某个commit之后的所有变动，每个commit占据一行&gt; <strong>git log [tag] HEAD –pretty=format:%s</strong></p><p>#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件&gt; <strong>git log [tag] HEAD –grep feature</strong></p><p>#显示某个文件的版本历史，包括文件改名&gt; <strong>git log –follow [file]&gt; git whatchanged [file]</strong></p><p>#显示指定文件相关的每一次diff&gt; <strong>git log -p [file]</strong></p><p>#显示过去5次提交&gt; <strong>git log -5 –pretty –oneline</strong></p><p>#显示所有提交过的用户，按提交次数排序&gt; <strong>git shortlog -sn</strong></p><p>#显示指定文件是什么人在什么时间修改过&gt; <strong>git blame [file]</strong></p><p>#显示暂存区和工作区的差异&gt; <font color="Red">git diff</font></p><p>#显示暂存区和上一个commit的差异&gt; <strong>git diff –cached [file]</strong></p><p>#显示工作区与当前分支最新commit之间的差异&gt; <strong>git diff HEAD</strong></p><p>#显示两次提交之间的差异&gt; <strong>git diff [first-branch]…[second-branch]</strong></p><p>#显示今天你写了多少行代码&gt; <strong>git diff –shortstat “@{0 day ago}”</strong></p><p>#显示某次提交的元数据和内容变化&gt; <font color="Red">git show commit</font></p><p>#显示某次提交发生变化的文件&gt; <strong>git show –name-only [commit]</strong></p><p>#显示某次提交时，某个文件的内容&gt; <strong>git show [commit]:[filename]</strong></p><p>#显示当前分支的最近几次提交&gt; <strong>git reflog</strong></p></blockquote><h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h3><blockquote><p>#下载远程仓库的所有变动&gt; <strong>git fetch [remote]</strong></p><p>#显示所有远程仓库&gt; <strong>git remote -v</strong></p><p>#显示某个远程仓库的信息&gt; <strong>git remote show [remote]</strong></p><p>#增加一个新的远程仓库，并命名&gt; <strong>git remote add [shortname] [url]</strong></p><p>#取回远程仓库的变化，并与本地分支合并&gt;  <font color="Red">git pull [remote] [branch]</font></p><p>#上传本地指定分支到远程仓库&gt; <font color="Red">git push [remote] [branch]</font></p></blockquote><blockquote><p>#强行推送当前分支到远程仓库，即使有冲突&gt; <strong>git push [remote] –force</strong></p><p>#推送所有分支到远程仓库&gt; <strong>git push [remote] –all</strong></p></blockquote><h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h3><blockquote><p>#恢复暂存区的指定文件到工作区&gt; <strong>git checkout [file]</strong></p><p>#恢复某个commit的指定文件到暂存区和工作区&gt; <strong>git checkout [commit] [file]</strong></p><p>#恢复暂存区的所有文件到工作区&gt; <strong>git checkout .</strong></p><p>#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变&gt; <font color="Red">git reset [file]</font></p><p>#重置暂存区与工作区，与上一次commit保持一致&gt; <strong>git reset –hard</strong></p><p>#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变&gt; <strong>git reset [commit]</strong></p><p>#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致&gt; <strong>git reset –hard [commit]</strong></p><p>#重置当前HEAD为指定commit，但保持暂存区和工作区不变&gt; <strong>git reset –keep [commit]</strong></p><p>#新建一个commit，用来撤销指定commit</p><p>#后者的所有变化都将被前者抵消，并且应用到当前分支&gt; <strong>git revert [commit]</strong></p><p>#暂时将未提交的变化移除，稍后再移入&gt; <strong>git stash&gt; git stash pop</strong></p></blockquote><h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><blockquote><p>#生成一个可供发布的压缩包&gt; <strong>git archive</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git做为一个开源的分布式版本控制系统,程序员的必备技能之一,今天就来总结一下关于Git的常用命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://qbqb.pro/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity基本原理分析</title>
    <link href="http://qbqb.pro/2018/08/31/SpringSecurity%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://qbqb.pro/2018/08/31/SpringSecurity基本原理/</id>
    <published>2018-08-31T09:25:56.000Z</published>
    <updated>2018-09-03T09:44:37.941Z</updated>
    
    <content type="html"><![CDATA[<p><em>SpringSecurity</em> 是一个能够基于 <em>Spring</em> 的企业应用系统提供声明式的安全框架<a id="more"></a></p><h3 id="它能做什么"><a href="#它能做什么" class="headerlink" title="它能做什么"></a>它能做什么</h3><blockquote><p><strong>认证:</strong> 识别当前用户是谁<br><strong>授权:</strong> 判断当前用户是否有权限进行相关操作<br><strong>安全防护:</strong> 防止伪造身份</p></blockquote><p>如果要对 Web 资源进行保护，最好的方法莫过于 Filter, 要项对方法调用进行保护，最好的方法莫过于AOP, <code>(ﾉ ○ Д ○)ﾉ</code>。</p><h3 id="它是如何实现的"><a href="#它是如何实现的" class="headerlink" title="它是如何实现的"></a>它是如何实现的</h3><p>下面来简单的介绍一个 <strong>SpringSecurity 基本原理</strong> :<br>当一个请求要访问我们受 <strong>SpringSecurity</strong> 保护的 Web 资源的时候, 会先经过我们在 <em>Spring</em> 中设置的关于 <strong>SpringSecurity</strong> 的多层过滤器链,(如 <strong>UsernamePasswordAuthenticationFilter</strong>, <strong>BasicAuthenticationFilter</strong>),一个过滤器一个过滤器往下走,每通过一个过滤器的认证就会添加在请求中添加一个标记。如下图所示:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/31/SpringSecurity基本原理/filter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>然后勒，这些 Filter 怎么和我们的数据库联系在一起勒？</p><p>这些 <strong>Filter</strong> 并不直接处理用户的认证，也不直接处理用户的授权，而是把它们交给认证管理器 <strong>AuthenticationManager</strong> 和决策管理器 <strong>AccessDecisionManager</strong>。SpringSecurity 提供了多个Provider的实现类，拿 <strong>UsernamePasswordAuthenticationFilter</strong>举例，当我们调用这个 <strong>Filter</strong>，并通过<strong>AuthenticationManager</strong>调用到 <strong>DaoAuthenticationProvider</strong>, 这个 <strong>Provider</strong> 可以调用数据库来存储用户的认证数据。对于<strong>Voter</strong>，我们一般选择<strong>RoleVoter</strong>就够用了，它会根据我们配置中的设置来决定是否允许某一个用户访问制定的Web资源。认证跟授权的流程如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/31/SpringSecurity基本原理/认证和授权.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p> <strong>DaoAuthenticationProvider</strong>不直接操作数据库的，它把任务委托给了 <strong>UserDetailService</strong>，我们要做的就是现实 <strong>UserDetailService</strong>, 它既是连接我们数据库跟SpringSecurity的桥梁。UserDetailService 的要求也很简单，只需要返回一个 <strong>org.springframework.security.userdetails.User</strong> 对象的 <strong>loadUserByUsername(String userName)</strong> 方法<br>。因此，怎么设计数据库都可以，不管我们是用一个表还是两个表还是三个表，也不管我们是用户-授权，还是用户-角色-授权，还是用户-用户组-角色-授权，这些具体的东西 <strong>SpringSecurity</strong> 统统不关心，它只关心返回的那个User对象，至于怎么从数据库中读取数据，那就是我们自己的事了。</p><p><strong>UserDetailService</strong> 实现类部分代码,模拟从数据库中获取用户信息:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        User user = userRepository.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(username);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyUserPrincipal(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyUserPrincipal定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserPrincipal</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUserPrincipal</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SpringSecurity 不关心你用了几个表，它只关心UserDetails对象。而决定用户能否访问指定Web资源的，是RoleVoter类，无需任何修改它可以工作得很好，唯一的缺点是它只认ROLE_前缀。</p><h3 id="它的常用-Filter-总结"><a href="#它的常用-Filter-总结" class="headerlink" title="它的常用 Filter 总结"></a>它的常用 Filter 总结</h3><p>SpringSecurity 提供的Filter 不少，不过常用的只有这么几个，下面我们来总结一下：</p><blockquote><p><strong>ChannelProcessingFilter:</strong>  制定必须为https连接<br><strong>LogoutFilter:</strong>退出登录<br><strong>UsernamePasswordAuthenticationFilter:</strong> 账号密码登录<br><strong>RememberMeAuthenticationFilter:</strong> 记住用户<br><strong>FilterSecurityInterceptor:</strong> 这个过滤器是整个SpringSecurity过滤器链的最后一环</p></blockquote><p>接下来简短的来谈一谈，<strong>FilterSecurityInterceptor</strong> 这个过滤器的最后一环，也是最重要的一环。它的父类<strong>AbstractSecurityInterceptor</strong> 是一个实现了对受保护对象的访问进行拦截的抽象类,该抽象类包含了<strong>AccessDecisionManager(决策管理器)</strong>、<strong>AuthenticationManager(身份认证管理器)</strong>的setter， 可以通过<strong>Spring</strong> 自动注入，另外，资源角色授权器需要单独自定义注入。</p><p>其中有几个比较重要的方法,都会在<code>FilterSecurityInterceptor</code>中被调用:</p><blockquote><p><strong>beforeInvocation()方法:</strong> 实现了对访问受保护对象的权限校验，内部用到了<code>AccessDecisionManager</code>和<code>AuthenticationManager</code>;<br><strong>finallyInvocation()方法:</strong> 用于实现受保护对象请求完毕后的一些清理工作，主要是如果在<code>beforeInvocation()</code>中改变了<code>SecurityContext</code>，则在<code>finallyInvocation()</code>中需要将其恢复为原来的<code>SecurityContext</code>,该方法的调用应当包含在子类请求受保护资源时的finally语句块中;<br><strong>afterInvocation()方法:</strong> 实现了对返回结果的处理，在注入了AfterInvocationManager的情况下默认会调用其decide()方法。</p></blockquote><p>来看看 <code>FilterSecurityInterceptor</code> 的部分源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 。。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        FilterInvocation fi = <span class="keyword">new</span> FilterInvocation(request, response, chain);</span><br><span class="line">        <span class="keyword">this</span>.invoke(fi);    <span class="comment">//  invoke() 在Filter 的 doFilter（）中被调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FilterSecurityInterceptor 的核心代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span> &amp;&amp; fi.getRequest().getAttribute(<span class="string">"__spring_security_filterSecurityInterceptor_filterApplied"</span>) != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fi.getRequest().setAttribute(<span class="string">"__spring_security_filterSecurityInterceptor_filterApplied"</span>, Boolean.TRUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类的beforeInvocation方法，该方法实现了对访问受保护对象的权限校验，</span></span><br><span class="line">    <span class="comment">// 内部调用到了`AccessDecisionManager`和`AuthenticationManager`</span></span><br><span class="line">            InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 调用父类的finallyInvocation方法, 用于实现受保护对象请求完毕后的一些清理工作</span></span><br><span class="line">                <span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">// 用父类的afterInvocation方法,实现了对返回结果的处理，</span></span><br><span class="line">  <span class="comment">// 在注入了AfterInvocationManager的情况下默认会调用其decide()方法。</span></span><br><span class="line">            <span class="keyword">super</span>.afterInvocation(token, (Object)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 。。。。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最后说点什么"><a href="#最后说点什么" class="headerlink" title="最后说点什么"></a>最后说点什么</h3><p>感觉最后不说点什么，有点奇怪。。。<br>笔者目前也在学习的<strong>SpringSecurity</strong>， 目前是一个阶段性的总结，以后如果有更深的理解会继续更新。笔者并没有讲具体的实现细节，只是大概的过了一遍SpringSecurity的执行过程，有遗漏的错误的地方欢迎指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;SpringSecurity&lt;/em&gt; 是一个能够基于 &lt;em&gt;Spring&lt;/em&gt; 的企业应用系统提供声明式的安全框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://qbqb.pro/tags/Spring/"/>
    
      <category term="Java" scheme="http://qbqb.pro/tags/Java/"/>
    
      <category term="SpringSecurity" scheme="http://qbqb.pro/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>记一次git错误解决</title>
    <link href="http://qbqb.pro/2018/08/27/%E8%AE%B0%E4%B8%80%E6%AC%A1git%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%EF%BC%8C%E5%9B%9E%E9%A1%BEgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://qbqb.pro/2018/08/27/记一次git错误解决，回顾git常用命令/</id>
    <published>2018-08-27T02:23:06.000Z</published>
    <updated>2018-08-27T10:46:15.244Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次 git 错误，<strong> fatal: Path ‘XXX’ is in submodule ‘XXX’ </strong><br><a id="more"></a></p><p>将Hexo博客部署到 Github 跟 Codeing 的 Pages 之后，为了能方便的在其他电脑也能随时更新博客文章、Hexo 配置文件和主题配置文件，我们在 GitHub Pages 仓库上创建了一个名为 Hexo 的分支，用来存放 Hexo 博客的网站文件。具体的操作步骤参考<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener"><strong> 知乎上的一个高赞回复 </strong></a> 这里不详细展开 <strong> (ˉ▽ˉ；)… </strong> ）。创建分支 Hexo ,将网站文件提交到分支，在另外一台电脑 pull 下分支中网站文件，安装相关模块，一气呵成。。。</p><p>可是在<code>hexo server</code>本地运行的时候,无法运行? 检查了主题文件夹目录下 <code>themes/indigo</code> 既然是空的，远程仓库中的对应的文件夹图标往常不同，画风都变了 <code>(ﾉ ○ Д ○)ﾉ</code> ，还无法点击查看下级目录，与下图的图标类似：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/27/记一次git错误解决，回顾git常用命令/github显示.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一开始以为该文件目录,忘记推送至远程仓库，所以打算重新将该文件夹下的文件添加至暂存区，git add themes/indigo/* ,可是既然报错了, 错误信息 <code>** fatal: Path &#39;XXX&#39; is in submodule &#39;XXX&#39; **</code> ???</p><p>仔细对比了themes/indigo 下的文件，发现该文件既然有一个 .git 目录，推测是由于一个 git 项目下无法识别其他的 git 项目。</p><ul><li>把 <code>indigo</code> 主题文件复制一份删除 .git 文件</li><li><p>从当前的工作空间中和索引中删除主题文件 <code>indigo</code></p><blockquote><p> git rm -rf themes/indigo</p></blockquote></li><li><p>将 <code>indigo</code> 主题文件复制到原来的主题问题目录下，添加暂存区，提交版本库，推送分支<br>完成。<br>重新再另外一台电脑 拉取分支，可以正常运行~~~</p><!-- <img src="/github显示.png"> –&gt;</li></ul>--></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一次 git 错误，&lt;strong&gt; fatal: Path ‘XXX’ is in submodule ‘XXX’ &lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://qbqb.pro/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 使用小记</title>
    <link href="http://qbqb.pro/2018/08/20/Hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
    <id>http://qbqb.pro/2018/08/20/Hexo使用小记/</id>
    <published>2018-08-20T06:06:12.000Z</published>
    <updated>2018-08-27T09:04:25.561Z</updated>
    
    <content type="html"><![CDATA[<p>hexo 是一个快速、简洁且高效的博客框架<a id="more"></a>，本网站由Hexo 搭建而成，使用了的主题是有着Design风格的Hexo主题 indigo。下面我们简单的总结一下搭建过程。</p><blockquote><p>参考 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a><br>参考 <a href="https://youngwilliamz.github.io/2018-07-10-Hexo-Markdown/" target="_blank" rel="noopener">Hexo 使用MD编辑技巧 </a><br>参考 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">Material Design风格的Hexo主题</a><br>参考 <a href="https://www.jianshu.com/p/86557c34b671" target="_blank" rel="noopener">Hexo Seo优化</a></p></blockquote><h3 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h3><p>安装前,请检查电脑中是否安装下列应用程序</p><blockquote><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener"><code>Node.js</code></a><br><a href="https://git-scm.com/" target="_blank" rel="noopener"><code>Git</code></a></p></blockquote><p>没有的话，请先安装吧,建议最新版本，可以避免部分安装上的错误。如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><blockquote><p><code>npm install -g hexo-cli</code></p></blockquote><h3 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h3><blockquote><p>hexo init [folder]         <code># 新建网站，folder为文件夹名</code><br>hexo clean                <code># 清除缓存文件</code><br>hexo g -d                     <code># 生成静态文件，并自动部署网站</code><br>hexo new “postname”         <code># 新建一篇文章</code><br>hexo server                 <code># 启动服务器</code></p></blockquote><h3 id="Hexo-目录结构"><a href="#Hexo-目录结构" class="headerlink" title="Hexo 目录结构"></a>Hexo 目录结构</h3><p> 使用新建网站命令创建Hexo的目录结构</p><blockquote><p>hexo init <code>folder</code><br>cd <code>folder</code><br>npm install</p></blockquote><p>整个过程只需要两三分钟左右的时间 emmmm…. , 文件的目录结构如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/20/Hexo使用小记/目录结构图.png" alt="目录结构图" title="">                </div>                <div class="image-caption">目录结构图</div>            </figure><br><strong> 下面是比较常用到的几个文件 </strong></p><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的配置信息，可以在此配置大部分的参数,在新建Hexo 目录的根路径上</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="Hexo-主题安装"><a href="#Hexo-主题安装" class="headerlink" title="Hexo 主题安装"></a>Hexo 主题安装</h3><p>安装该主题需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令</p><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:yscoder/hexo-theme-indigo.git themes/indigo</p></blockquote><p>并编辑站点配置文件，<strong> _config.yml </strong> 启用主题 <strong> theme: indigo </strong>,详细配置信息可查看<a href="https://github.com/yscoder/hexo-theme-indigo/wiki" target="_blank" rel="noopener">文档</a>,根据具体自己的需求进行配置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/20/Hexo使用小记/主题效果.png" alt="主题效果" title="">                </div>                <div class="image-caption">主题效果</div>            </figure><hr><p>后续补充<br><!-- <img src="/主题效果.png" width="300" height="400"> –&gt;</p>--></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo 是一个快速、简洁且高效的博客框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://qbqb.pro/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客，该写点什么~</title>
    <link href="http://qbqb.pro/2018/08/16/first/"/>
    <id>http://qbqb.pro/2018/08/16/first/</id>
    <published>2018-08-16T12:00:28.000Z</published>
    <updated>2018-08-16T13:34:44.066Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>这是我在这个网站写的<strong>第一篇博客</strong>，不知到写点什么好， emmmmm~  一个人如果做的东西没有特点就很难得到别人的喜欢，我是一个比较愚钝的人，踩过很多坑，努力填了很多坑，同时也认识到了自己的不足，这是一个用来记录我学习踩坑的地方。</p><h4 id="在这里送上我最喜欢的两句话"><a href="#在这里送上我最喜欢的两句话" class="headerlink" title="在这里送上我最喜欢的两句话"></a>在这里送上我最喜欢的两句话</h4><blockquote><p>我们使用时间的方式就是我们塑造自己的方式。</p></blockquote><blockquote><p>我们的人生是因为有爱，才突显了光；是因为有消逝，所以存在才会有意义。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
      <category term="记录" scheme="http://qbqb.pro/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法测试</title>
    <link href="http://qbqb.pro/2018/08/14/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://qbqb.pro/2018/08/14/我的世界/</id>
    <published>2018-08-14T02:21:10.000Z</published>
    <updated>2018-08-15T05:45:30.332Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言,它用简洁的语法代替排版,使我们专心于码字<br><a id="more"></a></p><h3 id="markdown语法”-”表示三级标题，二级标题，一级标题向上类推"><a href="#markdown语法”-”表示三级标题，二级标题，一级标题向上类推" class="headerlink" title="markdown语法”###”表示三级标题，二级标题，一级标题向上类推"></a>markdown语法”###”表示三级标题，二级标题，一级标题向上类推</h3><ul><li>无序列表用”*”表示</li><li>攻击防护( 防止伪造身份 )</li></ul><h3 id="普通的代码块-用-codeblock-与-endcodeblock-标记"><a href="#普通的代码块-用-codeblock-与-endcodeblock-标记" class="headerlink" title="普通的代码块 用 codeblock 与 endcodeblock 标记"></a>普通的代码块 用 codeblock 与 endcodeblock 标记</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相对路径引用的标签插件"><a href="#相对路径引用的标签插件" class="headerlink" title="相对路径引用的标签插件"></a>相对路径引用的标签插件</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/我的世界/test1.jpg" alt="测试图片" title="">                </div>                <div class="image-caption">测试图片</div>            </figure><img src="/2018/08/14/我的世界/test2.png" width="100" height="100">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown 是一种轻量级标记语言,它用简洁的语法代替排版,使我们专心于码字&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://qbqb.pro/tags/Hexo/"/>
    
      <category term="markdown" scheme="http://qbqb.pro/tags/markdown/"/>
    
  </entry>
  
</feed>
