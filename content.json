{"meta":{"title":"LQQB's Blog (ง •̀_•́)ง","subtitle":"将一个大问题分解为若干小问题，然后一个一个解决","description":"将一个大问题分解为若干小问题，然后一个一个解决","author":"lqqb","url":"http://qbqb.pro"},"pages":[{"title":"My Blog Name | 404","date":"2018-08-14T07:58:06.720Z","updated":"2018-08-14T07:58:06.720Z","comments":true,"path":"404.html","permalink":"http://qbqb.pro/404.html","excerpt":"","text":""},{"title":"","date":"2018-08-14T05:36:59.607Z","updated":"2018-08-14T05:36:59.607Z","comments":false,"path":"categories/index.html","permalink":"http://qbqb.pro/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-08-14T05:32:22.497Z","updated":"2018-08-14T05:32:22.497Z","comments":false,"path":"tags/index.html","permalink":"http://qbqb.pro/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java集合——集合框架汇总","slug":"Java集合——集合框架汇总","date":"2018-09-18T03:18:59.000Z","updated":"2018-09-18T07:19:59.125Z","comments":true,"path":"2018/09/18/Java集合——集合框架汇总/","link":"","permalink":"http://qbqb.pro/2018/09/18/Java集合——集合框架汇总/","excerpt":"集合是在任何语言中都是重要的基础知识，不同的集合在实现上采用了各种不同的数据结构。","text":"集合是在任何语言中都是重要的基础知识，不同的集合在实现上采用了各种不同的数据结构。接下来就从Java集合框架的层次关系开始入手，来理解Java的集合框架。 层次关系一个好的框架会在设计上考虑将接口与实现分离，而 Java集合框架从接口的整体设计就可以快速明确这个框架的作用和功能。 通过上面的接口框架图可以看出: Collection 和 Map&lt;K,V&gt; 是java.util 框架中的两个根接口，代表了两种不同的数据结构:集合和映射。 下面我们来分别来说下这些核心接口的基本功能: Collection&lt; E &gt;Collection&lt; E &gt;接口是集合的根接口，他代表了一组元素。但是Collection并不关心这组元素是否重复，是否有序。他只提供操作对这组元素的基本操作方法，怎么添加，怎么删除，怎么循环。所有的实现类都必须提供这些方法。 Iterable所有的集合类，都实现了Iterator方法Iterator&lt;E&gt; iterator() ，Iterator&lt; E &gt; 这是一个用于遍历集合中元素的接口，主要包含以下三种方法： hasNext() 是否还有下一个元素。 next() 返回下一个元素。 remove() 删除当前元素。 Map&lt;K,V&gt;API说明上关于Map&lt;K,V&gt;的说明非常精炼：从键映射到值的一个对象，键不能重复，每个键至多映射到一个值。 从键不能重复这个特点很容易想到通过Set来实现键，他的接口方法Set keySet()也证明了这点 List&lt; E &gt;（有序、可重复）List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 Set&lt; E &gt;（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 除了上述的接口以及抽象类以外，java.util框架还提供了一些其他结构，在使用频率上不是太高，比如Queue&lt; E &gt; ，Deque&lt; E &gt; 等。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://qbqb.pro/tags/Java/"}]},{"title":"浏览器身份标识User-Agent的故事","slug":"浏览器身份标识User-Agent的故事","date":"2018-09-10T03:38:15.000Z","updated":"2018-09-10T06:42:36.360Z","comments":true,"path":"2018/09/10/浏览器身份标识User-Agent的故事/","link":"","permalink":"http://qbqb.pro/2018/09/10/浏览器身份标识User-Agent的故事/","excerpt":"你是否好奇标识浏览器身份的User-Agent，为什么每个浏览器都有Mozilla字样？","text":"你是否好奇标识浏览器身份的User-Agent，为什么每个浏览器都有Mozilla字样？ 原文：http://webaim.org/blog/user-agent-string-history/译文：http://www.cnblogs.com/ifantastic/p/3481231.html译者：iFantasticMe 举例: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36Mozilla/5.0 (Linux; U; Android 4.1.2; zh-tw; GT-I9300 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) Gecko/20100101 Firefox/20.0Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0) 故事还得从头说起，最初的主角叫NCSA Mosaic，简称Mosaic（马赛克），是1992年末位于伊利诺伊大学厄巴纳-香槟分校的国家超级计算机应用中心（National Center for Supercomputing Applications，简称NCSA）开发，并于1993年发布的一款浏览器。它自称“NCSA_Mosaic/2.0（Windows 3.1）”，Mosaic可以同时展示文字和图片，从此浏览器变得有趣多了。 然而很快就出现了另一个浏览器，这就是著名的Mozilla，中文名称摩斯拉。一说 Mozilla = Mosaic + Killer，意为Mosaic杀手，也有说法是 Mozilla = Mosaic &amp; Godzilla，意为马赛克和哥斯拉，而Mozilla最初的吉祥物是只绿色大蜥蜴，后来更改为红色暴龙，跟哥斯拉长得一样。但Mosaic对此非常不高兴，于是后来Mozilla更名为Netscape，也就是网景。Netscape自称“Mozilla/1.0(Win3.1)”，事情开始变得更加有趣。网景支持框架（frame），由于大家的喜欢框架变得流行起来，但是Mosaic不支持框架，于是网站管理员探测user agent，对Mozilla浏览器发送含有框架的页面，对非Mozilla浏览器发送没有框架的页面。 后来网景拿微软寻开心，称微软的Windows是“没有调试过的硬件驱动程序”。微软很生气，后果很严重。此后微软开发了自己的浏览器，这就是Internet Explorer，并希望它可以成为Netscape Killer。IE同样支持框架，但它不是Mozilla，所以它总是收不到含有框架的页面。微软很郁闷很快就沉不住气了，它不想等到所有的网站管理员都了解IE并且给IE发送含有框架的页面，它选择宣布IE是兼容Mozilla，并且模仿Netscape称IE为“Mozilla/1.22(compatible; MSIE 2.0; Windows 95)”，于是IE可以收到含有框架的页面了，所有微软的人都嗨皮了，但是网站管理员开始晕了。 因为微软将IE和Windows捆绑销售，并且把IE做得比Netscape更好，于是第一次浏览器血腥大战爆发了，结果是Netscape以失败退出历史舞台，微软更加嗨皮。但没想到Netscape居然以Mozilla的名义重生了，并且开发了Gecko，这次它自称为“Mozilla/5.0(Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826”。Gecko是一款渲染引擎并且很出色。Mozilla后来变成了Firefox，并自称“Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108、Firefox/1.0”。Firefox性能很出色，Gecko也开始攻城略地，其他新的浏览器使用了它的代码，并且将它们自己称为“Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.2) Gecko/20040825 Camino/0.8.1”，以及“Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.8) Gecko/20071008 SeaMonkey/1.0”，每一个都将自己装作Mozilla，而它们全都使用Gecko。 Gecko很出色，而IE完全跟不上它，因此user agent探测规则变了，使用Gecko的浏览器被发送了更好的代码，而其他浏览器则没有这种待遇。Linux的追随者对此很难过，因为他们编写了Konqueror，它的引擎是KHTML，他们认为KHTML和Gecko一样出色，但却因为不是Gecko而得不到好的页面，于是Konqueror为得到更好的页面开始将自己伪装成“like Gecko”，并自称为“Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)”。自此user agent变得更加混乱。 这时更有Opera跳出来说“毫无疑问，我们应该让用户来决定他们想让我们伪装成哪个浏览器。”于是Opera干脆创建了菜单项让用户自主选择让Opera浏览器变成“Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51”，或者“Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51”， 或者“Opera/9.51 (Windows NT 5.1; U; en)”。 后来苹果开发了Safari浏览器，并使用KHTML作为渲染引擎，但苹果加入了许多新的特性，于是苹果从KHTML另辟分支称之为WebKit，但它又不想抛弃那些为KHTML编写的页面，于是Safari自称为“Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5”，这进一步加剧了user agent的混乱局面。 因为微软十分忌惮Firefox，于是IE重装上阵，这次它自称为“Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) ”，并且渲染效果同样出色，但是需要网站管理员的指令它这么做才行。 再后来，谷歌开发了Chrome浏览器，Chrome使用Webkit作为渲染引擎，和Safari之前一样，它想要那些为Safari编写的页面，于是它伪装成了Safari。于是Chrome使用WebKit，并将自己伪装成Safari，WebKit伪装成KHTML，KHTML伪装成Gecko，最后所有的浏览器都伪装成了Mozilla，这就是为什么所有的浏览器User-Agent里都有Mozilla。Chrome自称为“Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13”。 因为以上这段历史，现在的User-Agent字符串变得一团糟，几乎根本无法彰显它最初的意义。追根溯源，微软可以说是这一切的始作俑者，但后来每一个人都在试图假扮别人，最终把User-Agent搞得混乱不堪。 一句话结论：因为网站开发者可能会因为你是某浏览器（这里是 Mozilla），所以输出一些特殊功能的程序代码（这里指好的特殊功能），所以当其它浏览器也支持这种好功能时，就试图去模仿 Mozilla 浏览器让网站输出跟 Mozilla 一样的内容，而不是输出被阉割功能的程序代码。大家都为了让网站输出最好的内容，都试图假装自己是 Mozilla ,一个已经不存在的浏览器…… 附各大浏览器诞生年表： 1993年1月23日：Mosaic1994年12月：Netscape1994年：Opera1995年8月16日：Internet Explorer1996年10月14日：Kongqueror2003年1月7日：Safari2008年9月2日：Chrome","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"http://qbqb.pro/tags/记录/"},{"name":"浏览器","slug":"浏览器","permalink":"http://qbqb.pro/tags/浏览器/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2018-09-04T07:11:03.000Z","updated":"2018-09-04T10:03:51.193Z","comments":true,"path":"2018/09/04/git常用命令/","link":"","permalink":"http://qbqb.pro/2018/09/04/git常用命令/","excerpt":"Git做为一个开源的分布式版本控制系统,程序员的必备技能之一,今天就来总结一下关于Git的常用命令。","text":"Git做为一个开源的分布式版本控制系统,程序员的必备技能之一,今天就来总结一下关于Git的常用命令。Git 相比于其他的版本控制系统来说，唯一的缺点可能就是学习周期相对较长，且不符合常规思维。不过当你习惯了这种管理方式，就能看到 Git 的优点了。下面这张图就可以描述出 Git 的工作过程，以及我们开发日常中经常用到的 Git 命令。当然日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 参考自 阮一峰的网络日志 》常用 Git 命令清单 一、新建代码库 #在当前目录新建一个Git代码库git init #新建一个目录，将其初始化为Git代码库git init [project-name] #下载一个项目和它的整个代码历史 git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)。 #显示当前的Git配置git config –list #编辑Git配置文件git config -e [–global] #设置提交代码时的用户信息git config [–global] user.name “[name]”git config [–global] user.email “[email address]” 三、增加/删除文件 #添加指定文件到暂存区 git add [file1] [file2] … #添加指定目录到暂存区，包括子目录git add [dir] #添加当前目录的所有文件到暂存区 git add . #添加每个变化前，都会要求确认 #对于同一个文件的多处变化，可以实现分次提交git add -p #删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] … #停止追踪指定文件，但该文件会保留在工作区git rm –cached [file] #改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 四、代码提交 #提交暂存区到仓库区 git commit -m [message] #提交暂存区的指定文件到仓库区 git commit [file1] [file2] … -m [message] #提交工作区自上次commit之后的变化，直接到仓库区git commit -a #提交时显示所有diff信息git commit -v #使用一次新的commit，替代上一次提交 #如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit –amend -m [message] #重做上一次commit，并包括指定文件的新变化git commit –amend [file1] [file2] … 五、分支 #列出所有本地分支 git branch #列出所有远程分支git branch -r #列出所有本地分支和远程分支 git branch -a #新建一个分支，但依然停留在当前分支 git branch [branch-name] #新建一个分支，并切换到该分支 git checkout -b [branch] #新建一个分支，指向指定commitgit branch [branch] [commit] #新建一个分支，与指定的远程分支建立追踪关系git branch –track [branch] [remote-branch] #切换到指定分支，并更新工作区git checkout [branch-name] #切换到上一个分支 git checkout - #建立追踪关系，在现有分支与指定的远程分支之间git branch –set-upstream [branch] [remote-branch] #合并指定分支到当前分支git merge [branch] #选择一个commit，合并进当前分支git cherry-pick [commit] #删除分支git branch -d [branch-name] #删除远程分支git push origin –delete [branch-name]git branch -dr [remote/branch] 六、标签 #列出所有tag&gt; git tag #新建一个tag在当前commit&gt; git tag [tag] #新建一个tag在指定commit&gt; git tag [tag] [commit] #删除本地tag&gt; git tag -d [tag] #删除远程tag&gt; git push origin :refs/tags/[tagName] #查看tag信息&gt; git show [tag] #提交指定taggit push [remote] [tag] #提交所有taggit push [remote] –tags #新建一个分支，指向某个taggit checkout -b [branch] [tag] 七、查看信息 #显示 有变更的文件&gt; git status #显示 当前分支的版本历史&gt; git log #commit历史，以及每次commi&gt;发生变更的文件&gt; git log –stat #搜索提交历史，根据关键词&gt; git log -S [keyword] #显示某个commit之后的所有变动，每个commit占据一行&gt; git log [tag] HEAD –pretty=format:%s #显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件&gt; git log [tag] HEAD –grep feature #显示某个文件的版本历史，包括文件改名&gt; git log –follow [file]&gt; git whatchanged [file] #显示指定文件相关的每一次diff&gt; git log -p [file] #显示过去5次提交&gt; git log -5 –pretty –oneline #显示所有提交过的用户，按提交次数排序&gt; git shortlog -sn #显示指定文件是什么人在什么时间修改过&gt; git blame [file] #显示暂存区和工作区的差异&gt; git diff #显示暂存区和上一个commit的差异&gt; git diff –cached [file] #显示工作区与当前分支最新commit之间的差异&gt; git diff HEAD #显示两次提交之间的差异&gt; git diff [first-branch]…[second-branch] #显示今天你写了多少行代码&gt; git diff –shortstat “@{0 day ago}” #显示某次提交的元数据和内容变化&gt; git show commit #显示某次提交发生变化的文件&gt; git show –name-only [commit] #显示某次提交时，某个文件的内容&gt; git show [commit]:[filename] #显示当前分支的最近几次提交&gt; git reflog 八、远程同步 #下载远程仓库的所有变动&gt; git fetch [remote] #显示所有远程仓库&gt; git remote -v #显示某个远程仓库的信息&gt; git remote show [remote] #增加一个新的远程仓库，并命名&gt; git remote add [shortname] [url] #取回远程仓库的变化，并与本地分支合并&gt; git pull [remote] [branch] #上传本地指定分支到远程仓库&gt; git push [remote] [branch] #强行推送当前分支到远程仓库，即使有冲突&gt; git push [remote] –force #推送所有分支到远程仓库&gt; git push [remote] –all 九、撤销 #恢复暂存区的指定文件到工作区&gt; git checkout [file] #恢复某个commit的指定文件到暂存区和工作区&gt; git checkout [commit] [file] #恢复暂存区的所有文件到工作区&gt; git checkout . #重置暂存区的指定文件，与上一次commit保持一致，但工作区不变&gt; git reset [file] #重置暂存区与工作区，与上一次commit保持一致&gt; git reset –hard #重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变&gt; git reset [commit] #重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致&gt; git reset –hard [commit] #重置当前HEAD为指定commit，但保持暂存区和工作区不变&gt; git reset –keep [commit] #新建一个commit，用来撤销指定commit #后者的所有变化都将被前者抵消，并且应用到当前分支&gt; git revert [commit] #暂时将未提交的变化移除，稍后再移入&gt; git stash&gt; git stash pop 十、其他 #生成一个可供发布的压缩包&gt; git archive","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://qbqb.pro/tags/git/"}]},{"title":"SpringSecurity基本原理分析","slug":"SpringSecurity基本原理","date":"2018-08-31T09:25:56.000Z","updated":"2018-09-03T09:44:37.941Z","comments":true,"path":"2018/08/31/SpringSecurity基本原理/","link":"","permalink":"http://qbqb.pro/2018/08/31/SpringSecurity基本原理/","excerpt":"SpringSecurity 是一个能够基于 Spring 的企业应用系统提供声明式的安全框架","text":"SpringSecurity 是一个能够基于 Spring 的企业应用系统提供声明式的安全框架 它能做什么 认证: 识别当前用户是谁授权: 判断当前用户是否有权限进行相关操作安全防护: 防止伪造身份 如果要对 Web 资源进行保护，最好的方法莫过于 Filter, 要项对方法调用进行保护，最好的方法莫过于AOP, (ﾉ ○ Д ○)ﾉ。 它是如何实现的下面来简单的介绍一个 SpringSecurity 基本原理 :当一个请求要访问我们受 SpringSecurity 保护的 Web 资源的时候, 会先经过我们在 Spring 中设置的关于 SpringSecurity 的多层过滤器链,(如 UsernamePasswordAuthenticationFilter, BasicAuthenticationFilter),一个过滤器一个过滤器往下走,每通过一个过滤器的认证就会添加在请求中添加一个标记。如下图所示: 然后勒，这些 Filter 怎么和我们的数据库联系在一起勒？ 这些 Filter 并不直接处理用户的认证，也不直接处理用户的授权，而是把它们交给认证管理器 AuthenticationManager 和决策管理器 AccessDecisionManager。SpringSecurity 提供了多个Provider的实现类，拿 UsernamePasswordAuthenticationFilter举例，当我们调用这个 Filter，并通过AuthenticationManager调用到 DaoAuthenticationProvider, 这个 Provider 可以调用数据库来存储用户的认证数据。对于Voter，我们一般选择RoleVoter就够用了，它会根据我们配置中的设置来决定是否允许某一个用户访问制定的Web资源。认证跟授权的流程如下图： DaoAuthenticationProvider不直接操作数据库的，它把任务委托给了 UserDetailService，我们要做的就是现实 UserDetailService, 它既是连接我们数据库跟SpringSecurity的桥梁。UserDetailService 的要求也很简单，只需要返回一个 org.springframework.security.userdetails.User 对象的 loadUserByUsername(String userName) 方法。因此，怎么设计数据库都可以，不管我们是用一个表还是两个表还是三个表，也不管我们是用户-授权，还是用户-角色-授权，还是用户-用户组-角色-授权，这些具体的东西 SpringSecurity 统统不关心，它只关心返回的那个User对象，至于怎么从数据库中读取数据，那就是我们自己的事了。 UserDetailService 实现类部分代码,模拟从数据库中获取用户信息:123456789101112131415@Componentpublic class MyUserDetailsService implements UserDetailsService &#123; @Autowired private UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) &#123; User user = userRepository.findByUsername(username); if (user == null) &#123; throw new UsernameNotFoundException(username); &#125; return new MyUserPrincipal(user); &#125;&#125; MyUserPrincipal定义如下：12345678public class MyUserPrincipal implements UserDetails &#123; private User user; public MyUserPrincipal(User user) &#123; this.user = user; &#125; //...&#125; SpringSecurity 不关心你用了几个表，它只关心UserDetails对象。而决定用户能否访问指定Web资源的，是RoleVoter类，无需任何修改它可以工作得很好，唯一的缺点是它只认ROLE_前缀。 它的常用 Filter 总结SpringSecurity 提供的Filter 不少，不过常用的只有这么几个，下面我们来总结一下： ChannelProcessingFilter: 制定必须为https连接LogoutFilter:退出登录UsernamePasswordAuthenticationFilter: 账号密码登录RememberMeAuthenticationFilter: 记住用户FilterSecurityInterceptor: 这个过滤器是整个SpringSecurity过滤器链的最后一环 接下来简短的来谈一谈，FilterSecurityInterceptor 这个过滤器的最后一环，也是最重要的一环。它的父类AbstractSecurityInterceptor 是一个实现了对受保护对象的访问进行拦截的抽象类,该抽象类包含了AccessDecisionManager(决策管理器)、AuthenticationManager(身份认证管理器)的setter， 可以通过Spring 自动注入，另外，资源角色授权器需要单独自定义注入。 其中有几个比较重要的方法,都会在FilterSecurityInterceptor中被调用: beforeInvocation()方法: 实现了对访问受保护对象的权限校验，内部用到了AccessDecisionManager和AuthenticationManager;finallyInvocation()方法: 用于实现受保护对象请求完毕后的一些清理工作，主要是如果在beforeInvocation()中改变了SecurityContext，则在finallyInvocation()中需要将其恢复为原来的SecurityContext,该方法的调用应当包含在子类请求受保护资源时的finally语句块中;afterInvocation()方法: 实现了对返回结果的处理，在注入了AfterInvocationManager的情况下默认会调用其decide()方法。 来看看 FilterSecurityInterceptor 的部分源码：123456789101112131415161718192021222324252627282930313233343536373839public class FilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123; // 。。。。 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; FilterInvocation fi = new FilterInvocation(request, response, chain); this.invoke(fi); // invoke() 在Filter 的 doFilter（）中被调用 &#125; // FilterSecurityInterceptor 的核心代码 public void invoke(FilterInvocation fi) throws IOException, ServletException &#123; if (fi.getRequest() != null &amp;&amp; fi.getRequest().getAttribute(\"__spring_security_filterSecurityInterceptor_filterApplied\") != null &amp;&amp; this.observeOncePerRequest) &#123; fi.getChain().doFilter(fi.getRequest(), fi.getResponse()); &#125; else &#123; if (fi.getRequest() != null) &#123; fi.getRequest().setAttribute(\"__spring_security_filterSecurityInterceptor_filterApplied\", Boolean.TRUE); &#125; // 调用父类的beforeInvocation方法，该方法实现了对访问受保护对象的权限校验， // 内部调用到了`AccessDecisionManager`和`AuthenticationManager` InterceptorStatusToken token = super.beforeInvocation(fi); try &#123; fi.getChain().doFilter(fi.getRequest(), fi.getResponse()); &#125; finally &#123; // 调用父类的finallyInvocation方法, 用于实现受保护对象请求完毕后的一些清理工作 super.finallyInvocation(token); &#125; // 用父类的afterInvocation方法,实现了对返回结果的处理， // 在注入了AfterInvocationManager的情况下默认会调用其decide()方法。 super.afterInvocation(token, (Object)null); &#125; &#125; // 。。。。&#125; 最后说点什么感觉最后不说点什么，有点奇怪。。。笔者目前也在学习的SpringSecurity， 目前是一个阶段性的总结，以后如果有更深的理解会继续更新。笔者并没有讲具体的实现细节，只是大概的过了一遍SpringSecurity的执行过程，有遗漏的错误的地方欢迎指出。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://qbqb.pro/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://qbqb.pro/tags/Spring/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://qbqb.pro/tags/SpringSecurity/"}]},{"title":"记一次git错误解决","slug":"记一次git错误解决，回顾git常用命令","date":"2018-08-27T02:23:06.000Z","updated":"2018-08-27T10:46:15.244Z","comments":true,"path":"2018/08/27/记一次git错误解决，回顾git常用命令/","link":"","permalink":"http://qbqb.pro/2018/08/27/记一次git错误解决，回顾git常用命令/","excerpt":"记录一次 git 错误， fatal: Path ‘XXX’ is in submodule ‘XXX’","text":"记录一次 git 错误， fatal: Path ‘XXX’ is in submodule ‘XXX’ 将Hexo博客部署到 Github 跟 Codeing 的 Pages 之后，为了能方便的在其他电脑也能随时更新博客文章、Hexo 配置文件和主题配置文件，我们在 GitHub Pages 仓库上创建了一个名为 Hexo 的分支，用来存放 Hexo 博客的网站文件。具体的操作步骤参考 知乎上的一个高赞回复 这里不详细展开 (ˉ▽ˉ；)… ）。创建分支 Hexo ,将网站文件提交到分支，在另外一台电脑 pull 下分支中网站文件，安装相关模块，一气呵成。。。 可是在hexo server本地运行的时候,无法运行? 检查了主题文件夹目录下 themes/indigo 既然是空的，远程仓库中的对应的文件夹图标往常不同，画风都变了 (ﾉ ○ Д ○)ﾉ ，还无法点击查看下级目录，与下图的图标类似： 一开始以为该文件目录,忘记推送至远程仓库，所以打算重新将该文件夹下的文件添加至暂存区，git add themes/indigo/* ,可是既然报错了, 错误信息 ** fatal: Path &#39;XXX&#39; is in submodule &#39;XXX&#39; ** ??? 仔细对比了themes/indigo 下的文件，发现该文件既然有一个 .git 目录，推测是由于一个 git 项目下无法识别其他的 git 项目。 把 indigo 主题文件复制一份删除 .git 文件 从当前的工作空间中和索引中删除主题文件 indigo git rm -rf themes/indigo 将 indigo 主题文件复制到原来的主题问题目录下，添加暂存区，提交版本库，推送分支完成。重新再另外一台电脑 拉取分支，可以正常运行~~~","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://qbqb.pro/tags/git/"}]},{"title":"Hexo 使用小记","slug":"Hexo使用小记","date":"2018-08-20T06:06:12.000Z","updated":"2018-08-27T09:04:25.561Z","comments":true,"path":"2018/08/20/Hexo使用小记/","link":"","permalink":"http://qbqb.pro/2018/08/20/Hexo使用小记/","excerpt":"hexo 是一个快速、简洁且高效的博客框架","text":"hexo 是一个快速、简洁且高效的博客框架，本网站由Hexo 搭建而成，使用了的主题是有着Design风格的Hexo主题 indigo。下面我们简单的总结一下搭建过程。 参考 Hexo 官方文档参考 Hexo 使用MD编辑技巧 参考 Material Design风格的Hexo主题参考 Hexo Seo优化 Hexo 安装安装前,请检查电脑中是否安装下列应用程序 Node.jsGit 没有的话，请先安装吧,建议最新版本，可以避免部分安装上的错误。如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 npm install -g hexo-cli Hexo 常用命令 hexo init [folder] # 新建网站，folder为文件夹名hexo clean # 清除缓存文件hexo g -d # 生成静态文件，并自动部署网站hexo new “postname” # 新建一篇文章hexo server # 启动服务器 Hexo 目录结构 使用新建网站命令创建Hexo的目录结构 hexo init foldercd foldernpm install 整个过程只需要两三分钟左右的时间 emmmm…. , 文件的目录结构如下图： 目录结构图 下面是比较常用到的几个文件 _config.yml网站的配置信息，可以在此配置大部分的参数,在新建Hexo 目录的根路径上 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 Hexo 主题安装安装该主题需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令 git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 并编辑站点配置文件， _config.yml 启用主题 theme: indigo ,详细配置信息可查看文档,根据具体自己的需求进行配置 主题效果 后续补充","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://qbqb.pro/tags/Hexo/"}]},{"title":"第一篇博客，该写点什么~","slug":"first","date":"2018-08-16T12:00:28.000Z","updated":"2018-08-16T13:34:44.066Z","comments":true,"path":"2018/08/16/first/","link":"","permalink":"http://qbqb.pro/2018/08/16/first/","excerpt":"","text":"这是我在这个网站写的第一篇博客，不知到写点什么好， emmmmm~ 一个人如果做的东西没有特点就很难得到别人的喜欢，我是一个比较愚钝的人，踩过很多坑，努力填了很多坑，同时也认识到了自己的不足，这是一个用来记录我学习踩坑的地方。 在这里送上我最喜欢的两句话 我们使用时间的方式就是我们塑造自己的方式。 我们的人生是因为有爱，才突显了光；是因为有消逝，所以存在才会有意义。","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"http://qbqb.pro/tags/记录/"}]},{"title":"markdown语法测试","slug":"我的世界","date":"2018-08-14T02:21:10.000Z","updated":"2018-08-15T05:45:30.332Z","comments":true,"path":"2018/08/14/我的世界/","link":"","permalink":"http://qbqb.pro/2018/08/14/我的世界/","excerpt":"Markdown 是一种轻量级标记语言,它用简洁的语法代替排版,使我们专心于码字","text":"Markdown 是一种轻量级标记语言,它用简洁的语法代替排版,使我们专心于码字 markdown语法”###”表示三级标题，二级标题，一级标题向上类推 无序列表用”*”表示 攻击防护( 防止伪造身份 ) 普通的代码块 用 codeblock 与 endcodeblock 标记123public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args);&#125; 相对路径引用的标签插件 测试图片","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://qbqb.pro/tags/Hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://qbqb.pro/tags/markdown/"}]}]}